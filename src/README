lotem.rozner,shakedmishory
208987198,208017111

1. Design chosen in part 1.7:
To remove and add objects to the game, we chose to pass a gameObjectCollection. This way, every class that
has a gameObjectCollection can call the add and remove public methods of gameObjectCollection. An advantage
of this method over the second method is that passing only the game objects collection prevents other
classes from using public methods that are in BrickerGameManager, such as initializeGame. It follows
the encapsulation pillar that we learned about because we are hiding unnecessary information and
functionality in BrickerGameManager from all the other classes. Some disadvantage of this way
is that all of the classes that compose this collection get access to all game objects in the game.

2. Implementation of life counters:
We implemented two classes, GraphicCounter and NumericCounter. GraphicCounter is in charge of creating three
hearts to resemble the remaining life graphically, where each heart is a GameObject. This class adds and
removes heart game objects according to the remaining life counter of the game. NumericCounter is in
charge of the visual representation of the remaining life via a number with different colors, updating
the number shown and its color according to the remaining life. Both classes use life counter, which is
managed in BrickerGameManager class.

3.Special strategies behaviors:
--Choosing the strategy when creating the bricks:
    In order to create all the bricks in the game, each brick with its collision strategy, we created a class
    called BricksController which is in charge of creating all the bricks and all the collision strategies.
    In this class, each brick randomly picks a collision strategy from a given distribution and uses
    StrategyFactory to create the chosen strategy.
--Creating strategies:
    We used the factory design pattern to create all brick strategies. Using the factory allows us to create
    all the strategies in one place in the code, following the open-close principle. Moreover, only the
    factory is in charge of creating strategies, keeping encapsulation between the classes. The
    BricksController initializes the factory using the composition design pattern.
--Managing strategies:
    The StrategiesManager class handles all the necessary parameters for the strategies, and the factory has
    an instance of this class. In this way, the factory can get all the required parameters for creating
    strategies through the manager and focus only on the logic of creating them.
--BasicCollisionStrategy:
    All of the special strategy classes contain an instance of BasicCollisionStrategy for functionality.
    We chose the composition design pattern because each behavior also has the basic behavior. This way,
    we created only one instance of this behavior in the strategy factory and passed it to the special ones
    when creating them. It allows us to manage bricksCounter only in the basic collision rather than in all
    of the special strategies.
--Special strategies:
    1. AddPuckStrategy: This class adds two new Puck objects. We use the Puck class, which extends the Ball
     class, because they share the same functionality, and Puck is a kind of Ball. By doing so, we use
     inheritance. Creating the Puck class allows us to extend the Ball behavior by choosing a special
     direction. We implemented the DirectionStrategy interface in the puck_strategies package and two
     direction classes, BasicRandomStrategy and CircleUnitStrategy, which implement the interface. This way,
      we can add more strategies simply. This design pattern follows the open-close principle.
    2. AddPaddleStrategy: This class creates a special paddle using the SpecialPaddle class. SpecialPaddle
     extends the Paddle class because a special paddle is a paddle with extended on-collision behavior. It
     overrides the onCollision method and adds the desired behavior where the paddle disappears after 4
     collisions with balls and pucks.
    3. AddLifeStrategy: This class creates a fallenHeart which gives extra life using the FallenHeart class.
     FallenHeart creates a heart game object that adds life only when colliding with the original paddle.
    4. CameraStrategy: This class, upon collision with a designated main ball, triggers the creation of a
     camera object to follow the ball's movement within the game. The camera resets after 4 ball collisions.
      We implemented this by tracking the ball collisions counter by the time the camera is initialized.

4. Double Strategy design:
We implemented a DoubleStrategy class which receives an array of collision strategies that should be
activated by calling their onCollision methods. We create this strategy in the StrategyFactory because the
factory is the only place in our code that is in charge of creating brick special strategies, following the
encapsulation pillar. In the factory, we create the strategies array to be passed to the DoubleStrategy
class, meaning that DoubleStrategy is not aware of the specific selected strategies and their amount.
Limiting strategies per brick: The factory has a constant stating the maximum number of strategies per brick,
and the method which is in charge of building the strategies array uses this class constant. By changing only
this constant, we can change the maximum number of strategies we choose for a brick in the game.

5. No API changes.